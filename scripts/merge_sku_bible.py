import csv
import json
import os
import re

# Paths
BASE_DIR = r"c:\Users\thach\Downloads\Claude Cowork\SWISH"
PROGRAM_DIR = os.path.join(BASE_DIR, "SWISH_program")
TEAMWEAR_CSV = os.path.join(BASE_DIR, "teamwear_items.csv")
RETAIL_CSV = os.path.join(BASE_DIR, "retail_items.csv")
IMAGES_DIR = os.path.join(BASE_DIR, "teamwear_images")
OUTPUT_JSON = os.path.join(PROGRAM_DIR, "public", "data", "products.json")
OUTPUT_MAP = os.path.join(PROGRAM_DIR, "src", "utils", "imageMap.ts")

def run_merge():
    # 1. Load Teamwear Items
    print("Loading Teamwear items...")
    products = []
    with open(TEAMWEAR_CSV, mode='r', encoding='utf-8-sig') as f:
        reader = csv.DictReader(f)
        for row in reader:
            products.append({
                "sku": row.get("SKU", "").strip(),
                "name": row.get("Description", "").strip(),
                "barcode": row.get("Barcode", "").strip(),
                "warehouse": "Courtside Teamwear",
                "bin": "",
                "quantity": 0,
                "status": "Active"
            })

    # 2. Load Retail Items
    print("Loading Retail items...")
    with open(RETAIL_CSV, mode='r', encoding='utf-8-sig') as f:
        reader = csv.DictReader(f)
        for row in reader:
            products.append({
                "sku": row.get("SKU", "").strip(),
                "name": row.get("Description", "").strip(),
                "barcode": row.get("Barcode", "").strip(),
                "warehouse": "Courtside Retail",
                "bin": "",
                "quantity": 0,
                "status": "Active"
            })

    # 3. Save products.json
    print(f"Saving {len(products)} products to JSON...")
    os.makedirs(os.path.dirname(OUTPUT_JSON), exist_ok=True)
    with open(OUTPUT_JSON, 'w', encoding='utf-8') as f:
        json.dump({"item_master": products}, f, indent=2)

    # 4. Generate Image Map (Teamwear Only)
    print("Generating Teamwear image map...")
    image_files = [f for f in os.listdir(IMAGES_DIR) if f.lower().endswith(('.png', '.webp', '.jpg', '.jpeg'))]
    
    # Building the imageMap.ts content with O(1) optimization
    map_content = f"""// This file is auto-generated by scripts/merge_sku_bible.py
// It contains the list of all available Teamwear images and an O(1) matching helper.

const AVAILABLE_IMAGES = {json.dumps(image_files, indent=4)};

const PROJECT_URL = 'https://luekeyeoxoymchguhrdt.supabase.co';
const BUCKET = 'product-images';

// Optimized Image Indexing (O(M))
// We create a Map where the KEY is the baseName (filename without extension)
// and the VALUE is the full filename.
const IMAGE_INDEX = new Map<string, string>();
AVAILABLE_IMAGES.forEach(filename => {{
    const dotIndex = filename.lastIndexOf('.');
    if (dotIndex !== -1) {{
        const baseName = filename.substring(0, dotIndex).toUpperCase();
        // Priority: If multiple extensions exist, keep established one or first found
        if (!IMAGE_INDEX.has(baseName)) {{
            IMAGE_INDEX.set(baseName, filename);
        }}
    }}
}});

/**
 * Attempts to resolve a product image path based on the SKU.
 * Uses O(1) Map lookup for maximum performance across large datasets.
 */
export const resolveProductImage = (sku: string): string | undefined => {{
    if (!sku) return undefined;

    const normalizedSku = sku.toUpperCase();
    
    // 1. Exact Match Check (Quickest)
    let matchedFile = IMAGE_INDEX.get(normalizedSku);

    // 2. Segment Match Check
    // If no exact match, try stripping the last segment (e.g., "-L" for size)
    if (!matchedFile) {{
        const lastDash = normalizedSku.lastIndexOf('-');
        if (lastDash !== -1) {{
            const baseSku = normalizedSku.substring(0, lastDash);
            matchedFile = IMAGE_INDEX.get(baseSku);
        }}
    }}

    if (matchedFile) {{
        return `${{PROJECT_URL}}/storage/v1/object/public/${{BUCKET}}/${{encodeURIComponent(matchedFile)}}`;
    }}

    return undefined;
}};
"""
    
    with open(OUTPUT_MAP, 'w', encoding='utf-8') as f:
        f.write(map_content)

    print("Merge complete!")

if __name__ == "__main__":
    run_merge()
